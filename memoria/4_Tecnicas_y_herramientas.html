

<!DOCTYPE html>
<html class="writer-html5" lang="es" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Técnicas y herramientas &mdash; documentación de JIZT - AI Summarization - 0.1.0</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/favicon.png"/>
  

  
  

  
    <link rel="canonical" href="docs.jizt.it/memoria/4_Tecnicas_y_herramientas.html" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/js/custom.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="next" title="Aspectos relevantes del desarrollo del proyecto" href="5_Aspectos_relevantes_del_desarrollo_del_proyecto.html" />
    <link rel="prev" title="Conceptos teóricos" href="3_Conceptos_teoricos.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> JIZT - AI Summarization
          

          
            
            <img src="../_static/jizt-docs.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Memoria</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1_Introduccion.html">Introducción</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_Objetivos_del_proyecto.html">Objetivos del proyecto</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_Conceptos_teoricos.html">Conceptos teóricos</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Técnicas y herramientas</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#modelo-de-generacion-de-resumenes">Modelo de generación de resúmenes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#backend-plataforma-escalable-en-la-nube"><em>Backend</em> — Plataforma escalable en la nube</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#docker">Docker</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kubernetes">Kubernetes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kafka-y-strimzi">Kafka y Strimzi</a></li>
<li class="toctree-l3"><a class="reference internal" href="#helm">Helm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#crunchy-postgresql-operator">Crunchy PostgreSQL Operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#flask-y-flask-restful">Flask y Flask-RESTful</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#frontend-aplicacion-multiplataforma"><em>Frontend</em> — Aplicación multiplataforma</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#flutter">Flutter</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#desarrollo-nativo-plataformas-x64-arm">Desarrollo nativo (plataformas x64/ARM)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#desarrollo-web">Desarrollo <em>web</em></a></li>
<li class="toctree-l4"><a class="reference internal" href="#produccion-nativa-plataformas-x64-arm">Producción nativa (plataformas x64/ARM)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#produccion-web">Producción <em>web</em></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="5_Aspectos_relevantes_del_desarrollo_del_proyecto.html">Aspectos relevantes del desarrollo del proyecto</a></li>
<li class="toctree-l1"><a class="reference internal" href="6_Trabajos_relacionados.html">Trabajos relacionados</a></li>
<li class="toctree-l1"><a class="reference internal" href="7_Conclusiones_Lineas_de_trabajo_futuras.html">Conclusiones y Líneas de trabajo futuras</a></li>
</ul>
<p class="caption"><span class="caption-text">Anexos</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../anexos/A_Plan_proyecto.html">Plan de Proyecto Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../anexos/B_Requisitos.html">Especificación de Requisitos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../anexos/C_Diseno.html">Especificación de diseño</a></li>
<li class="toctree-l1"><a class="reference internal" href="../anexos/D_Manual_programador.html">Documentación técnica de programación</a></li>
<li class="toctree-l1"><a class="reference internal" href="../anexos/E_Manual_usuario.html">Documentación de usuario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../anexos/F_Experimentos.html">Experimentos sobre el algoritmo de división de texto</a></li>
</ul>
<p class="caption"><span class="caption-text">Ayúdanos</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../anexos/CONTRIBUTING.html">Contribuir a JIZT</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">JIZT - AI Summarization</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Técnicas y herramientas</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/memoria/4_Tecnicas_y_herramientas.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tecnicas-y-herramientas">
<span id="chapter-tecnicas-herramientas"></span><h1>Técnicas y herramientas<a class="headerlink" href="#tecnicas-y-herramientas" title="Enlazar permanentemente con este título">¶</a></h1>
<p>En este capítulo, se recogen las tecnologías principales empleadas en el
desarrollo del proyecto, así como los detalles más relevantes de su
implementación.</p>
<p>Para facilitar la organización y comprensión de las mismas, se han separado en tres
subsecciones: <a class="reference internal" href="#sec-model"><span class="std std-ref">Modelo</span></a>, en la que se detalla el funcionamiento del
modelo de generación de lenguaje empleado, <a class="reference internal" href="#sec-backend"><span class="std std-ref">Backend</span></a>, donde
profundizamos en la implementación del servicio escalable en la nube, y
<a class="reference internal" href="#sec-frontend"><span class="std std-ref">Frontend</span></a>, en la que explicamos todo lo referente a la
aplicación multiplataforma desarrollada.</p>
<div class="section" id="modelo-de-generacion-de-resumenes">
<span id="sec-model"></span><h2>Modelo de generación de resúmenes<a class="headerlink" href="#modelo-de-generacion-de-resumenes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Como se ha venido mencionando a lo largo de los anteriores capítulos, para la
generación de resúmenes se ha elegido el modelo T5 de Google. Más concretamente,
utilizamos la implementación <code class="docutils literal notranslate"><span class="pre">t5-large</span></code> de Hugging Face <a class="reference internal" href="#t5-hf" id="id1"><span>[t5-hf]</span></a>, el cual
ha sido entrenado con texto en inglés procedente del Colossal Clean Crawled Corpus
(C4), y contiene aproximadamente 770 millones de parámetros <a class="reference internal" href="#hf-pretrained" id="id2"><span>[hf-pretrained]</span></a>.</p>
<p>Esta implementación está escrita en Python, lo que nos facilita la
integración con el resto de componentes del <em>backend</em> de JIZT, también desarrollados
en Python.</p>
<p>El modelo <code class="docutils literal notranslate"><span class="pre">t5-large</span></code> consta, por un lado, del <em>tokenizer</em>, encargado
de la codificación del texto, y por otro, del modelo en sí, el cual
recibe el texto codificado por el <em>tokenizer</em>, y genera el resumen a
partir de él. Dicho resumen, sigue estando en forma de <em>tókenes</em>
codificados, por lo que tenemos que hacer uso una vez más del
<em>tokenizer</em> para proceder a su decodificación. Una vez decodificado, el
texto vuelve a contener caracteres legibles.</p>
<p>Tanto el proceso de codificación, como el de generación de resúmenes, se han
implementado de forma que se puedan llevar a cabo empleando unidades de procesamiento
gráfico (GPU). No obstante, en nuestro caso y por el momento, ambos procesos se
ejecutan en unidades centrales de procesamiento (CPU), debido a limitaciones
económicas<a class="footnote-reference brackets" href="#id24" id="id3">1</a>. Esto explica en parte los <a class="reference internal" href="6_Trabajos_relacionados.html#subsec-tabla-comparativa"><span class="std std-ref">tiempos de resumen obtenidos</span></a>, los cuales pueden resultar algo dilatados con textos muy
largos.</p>
<p>Un último aspecto a destacar es que a la hora de generar los resúmenes,
se pueden especificar los parámetros concretos con los que realizar
dicha generación, permitiéndonos hacer uso de las <a class="reference internal" href="3_Conceptos_teoricos.html#subsec-estrategias-gen"><span class="std std-ref">Principales estrategias de generación de resúmenes</span></a>
vistas anteriormente.</p>
</div>
<div class="section" id="backend-plataforma-escalable-en-la-nube">
<span id="sec-backend"></span><h2><em>Backend</em> — Plataforma escalable en la nube<a class="headerlink" href="#backend-plataforma-escalable-en-la-nube" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En la figura mostrada a continuación, se recoge una visión general de la arquitectura
que conforma el <em>backend</em> de JIZT, y que posibilita la implementación en la nube de
las diferentes etapas en la generación de resúmenes descritas en el capítulo de
<a class="reference internal" href="3_Conceptos_teoricos.html#chapter-conceptos-teoricos"><span class="std std-ref">Conceptos teóricos</span></a>.</p>
<div class="figure align-default" id="fig-overview-arch">
<img alt="Vista general de la arquitectura del *backend*. Los rectángulos en azul se corresponden con los microservicios de JIZT. Los rectángulos en amarillo, representan los *topics* de Kafka, explicados posteriormente." src="../_images/overview-arch1.png" />
<p class="caption"><span class="caption-number">Figura 17 </span><span class="caption-text">Vista general de la arquitectura del <em>backend</em>. Los rectángulos en
azul se corresponden con los microservicios de JIZT. Los rectángulos
en amarillo, representan los <em>topics</em> de Kafka, explicados
posteriormente.</span><a class="headerlink" href="#fig-overview-arch" title="Enlace permanente a esta imagen">¶</a></p>
</div>
<p>En esta arquitectura, existen diferentes tecnologías, cada una encargada de realizar
una tarea específica, pero a su vez integrándose con el resto. A grandes rasgos, y sin
ser necesario que el lector comprenda con exactitud todos los términos por ahora,
presentemos brevemente cuáles son las tecnologías empleadas.</p>
<p>En primer lugar, cada microservicio se encapsula en un contenedor <a class="reference external" href="https://www.docker.com">Docker</a>. De esta forma, además de modularizar cada microservicio,
podemos aumentar el número de réplicas de cada uno de ellos, permitiendo el escalado
de la arquitectura.</p>
<p>Por su parte, <a class="reference external" href="https://kubernetes.io">Kubernetes</a> se encarga de la <em>orquestración</em>
de los microservicios, ocupándose de aspectos como la replicación, configuración de
red y almacenamiento, gestión de los recursos del sistema, etc. El despliegue de los
componentes que componen Kubernetes se simplifica gracias al uso de otra herramienta,
<a class="reference external" href="https://helm.sh">Helm</a>.</p>
<p>Otra de las tecnologías usadas, <a class="reference external" href="https://kafka.apache.org">Apache Kafka</a>, permite
la comunicación entre los diferentes microservicios mediante eventos.</p>
<p>El despliegue de la base de datos PostgreSQL en Kubernetes encargada de almacenar los
resúmenes generados, corre a cargo del <a class="reference external" href="https://www.crunchydata.com/products/crunchy-postgresql-operator">Operador de PostgreSQL de Crunchy</a>.</p>
<p>Por último, la API REST se implementa a través de un popular <em>framework</em> para
Python, llamado <a class="reference external" href="https://flask.palletsprojects.com/en/1.1.x">Flask</a>.</p>
<p>Expliquemos, ahora sí, de forma detallada cómo funciona cada una de estas tecnologías.</p>
<div class="section" id="docker">
<h3>Docker<a class="headerlink" href="#docker" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Docker nos permite encapsular nuestros microservicios en contenedores.
De este modo, gracias a Kubernetes, podemos crear réplicas de cada
microservicio, haciendo posible el escalado de nuestro sistema.</p>
<p>A diferencia de las máquinas virtuales, en las cuales el sistema
operativo subyacente se comparte a través del hipervisor, cada
contenedor Docker ejecuta su propio sistema operativo, como podemos ver
en la siguiente figura:</p>
<div class="figure align-default" id="fig-vm-container">
<img alt="Comparativa de los diferentes enfoques en el despliegue de sistemas: desarrollo tradicional, desarrollo virtualizado, y desarrollo con contenedores [kubernetes]_." src="../_images/docker.png" />
<p class="caption"><span class="caption-number">Figura 18 </span><span class="caption-text">Comparativa de los diferentes enfoques en el despliegue de sistemas:
desarrollo tradicional, desarrollo virtualizado, y desarrollo con
contenedores <a class="reference internal" href="#id28" id="id4"><span>[kubernetes]</span></a>.</span><a class="headerlink" href="#fig-vm-container" title="Enlace permanente a esta imagen">¶</a></p>
</div>
<p>Otra ventaja de Docker es que nos permite distribuir la implementación
de nuestros microservicios a través imágenes, por lo que un
desarrollador que solo quisiera hacer uso de uno de los microservicios,
podría hacerlo de manera sencilla.</p>
</div>
<div class="section" id="kubernetes">
<h3>Kubernetes<a class="headerlink" href="#kubernetes" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El <em>backend</em> sigue una arquitectura de microservicios <a class="reference internal" href="#newman15" id="id5"><span>[newman15]</span></a>, de forma que cada
una de las etapas (pre-procesado, codificación, generación del resumen y
post-procesado), está confinada en un contenedor Docker <a class="reference internal" href="#id29" id="id6"><span>[docker]</span></a>, conformando un
microservicio. Adicionalmente, existe un microservicio más, el <em>Dispatcher</em>, el cual
lleva a cabo las siguientes tareas:</p>
<ul class="simple">
<li><p>Implementa una API REST que permite a los clientes solicitar
resúmenes.</p></li>
<li><p>Gestiona una base de datos en la que se almacenan los resúmenes
generados.</p></li>
<li><p>Redirige las peticiones de los clientes al microservicio apropiado.
Por ahora, todas las peticiones se redirigen hacia el pre-procesador
de textos, pero en un futuro podría existir otro microservicio que se
encargara, por ejemplo, de extraer el texto de un documento PDF o de
una página <em>web</em>. En estos casos, el <em>Dispatcher</em> se encargaría de
redirigirlo hacia el microservicio correspondiente.</p></li>
</ul>
<p>Kubernetes es una plataforma <em>open-source</em> destinada a la gestión de
servicios y cargas de trabajo en contenedores, facilitando su
automatización en cuanto a aspectos como el escalado, gestión de red y
recursos, monitorización, etc. <a class="reference internal" href="#id28" id="id7"><span>[kubernetes]</span></a>.</p>
<p>Kubernetes comprende numerosos componentes, entre los cuales, los más
relevantes para nuestro proyecto son:</p>
<ul class="simple">
<li><p><em>Pod</em>: es la unidad de computación básica en Kubernetes. Un <em>Pod</em>
puede ejecutar uno o varios contenedores intrínsecamente relacionados
(compartirán almacenamiento, red, recursos, etc.).</p></li>
<li><p><em>Deployment</em>: los <em>deployments</em> se pueden ver como «plantillas» o
«moldes» que contienen los detalles específicos para crear <em>pods</em>
de un determinado tipo. Por ejemplo, en el caso del mencionado
<em>Dispatcher</em>, dispondremos de un <em>deployment</em> que indicará cómo se
deben crear los <em>pods</em> para este servicio, todos ellos idénticos.
Estos <em>pods</em> a su vez, contendrán todos la misma imagen Docker que
implementará la lógica del servicio.</p></li>
<li><p><em>Service</em>: cada <em>pod</em> dispone de una dirección IP propia. Sin
embargo, los <em>pods</em> tienen un ciclo de vida <em>efímero</em>, dado que están
concebidos para ser reemplazados dinámicamente si se producen
errores, actualizaciones, etc. Por tanto, no podemos basar la
configuración de red en las IPs específicas de los <em>pods</em>, ya que
estás son susceptibles de cambiar a lo largo del tiempo, según los
<em>pods</em> vayan siendo reemplazados. Los <em>services</em> nos permiten asociar
una IP fija y persistente a un conjunto concreto de <em>pods</em>. A la hora
de realizar una conexión con dicha IP, Kubernetes se encarga de
remitir los datos al <em>pod</em> que esté menos ocupado en ese instante,
realizando por tanto un balance de carga de forma automática.</p></li>
<li><p><em>PersistentVolume</em>: al igual que en el caso de las IPs, los datos
almacenados localmente en un <em>pod</em> desaparecerán cuando este sea
reemplazado. Los <em>PersistentVolumes</em> nos proporcionan la capacidad de
almacenar datos de manera persistente, independientemente del ciclo
de vida de los <em>pods</em>. Nosotros, utilizamos este componente para
almacenar los modelos de generación de resúmenes, ya que ocupan
alrededor de 5 GB, de forma que los <em>pods</em> correspondientes a la
codificación de texto y generación del resumen consumen los modelos
desde una única fuente de datos, el <em>PersistentVolume</em>. Incluir los
modelos dentro de los propios <em>pods</em> sería contraproducente ya que
(a) todos los <em>pods</em> van a hacer uso de los mismos modelos, y (b) los
modelos tienen un tamaño del orden de <em>gigas</em>, por lo que si
quisiéramos crear varios <em>pods</em>, la demanda de almacenamiento
crecería rápida e innecesariamente.</p></li>
</ul>
<p>La figura mostrada a continuación pretende facilitar la comprensión de los diferentes
componentes de manera más visual. Como podemos ver en dicha figura, existen <em>n</em>
<em>pods</em>, todos ellos replicas de un mismo <em>deployment</em> y, por tanto, ejecutando los
mismos contenedores, pero cada uno de ellos con una dirección IP propia. El <em>service</em>
permite acceder a los diferentes <em>pods</em> a través de una única IP estática. Por último,
todos los <em>pods</em> consumen un mismo <em>PersistentVolume</em> que, por ejemplo, podría
contener los modelos ya mencionados.</p>
<div class="figure align-default" id="fig-k8s-components">
<img alt="Componentes principales de Kubernetes." src="../_images/kubernetes-components.png" />
<p class="caption"><span class="caption-number">Figura 19 </span><span class="caption-text">Componentes principales de Kubernetes.</span><a class="headerlink" href="#fig-k8s-components" title="Enlace permanente a esta imagen">¶</a></p>
</div>
<p>De este modo, podemos escalar (o actualizar) cada uno de los microservicios de forma
dinámica y sin periodos de inactividad (<em>downtime</em>). De hecho, Kubernetes permite
configurar dicho escalado de manera automática. Así, en momentos en los que la carga
de trabajo sea mayor, Kubernetes se encargará de crear <em>pods</em> adicionales para
responder ante dicha carga y, una vez esta desaparezca, los volverá a eliminar. Al
habilitar esta opción, es muy recomendable configurar el número máximo de <em>pods</em> que
se podrán crear, a fin de evitar un escalado descontrolado en momentos de carga
extrema (en cualquier caso, Kubernetes detendría la creación de <em>pods</em> tan pronto como
se consumieran los recursos disponibles del sistema <a class="reference internal" href="#k8s-scheduling" id="id8"><span>[k8s-scheduling]</span></a>).</p>
<p>Existe un último componente de Kubernetes del que hacemos uso, llamado
Ingress. Este componente implementa una API <em>Gateway</em>, enrutando las
peticiones API de los clientes hacia el microservicio correspondiente
<a class="reference internal" href="#api-gateway" id="id9"><span>[api-gateway]</span></a>. Por ahora, la API REST que hemos
implementado solo dispone de rutas relacionadas a la generación de
resúmenes, pero en un futuro, cuando se implementen otras tareas de NLP,
existirán otros <em>endpoints</em> para dichas tareas. Ingress se encargará
entonces de, en función de a qué <em>endpoint</em> se esté realizando la
petición, redirigirla al microservicio correspondiente.</p>
<div class="figure align-default" id="fig-k8s-ingress">
<a class="reference internal image-reference" href="../_images/kubernetes-ingress.png"><img alt="Ejemplo de un hipotético uso de Ingress con diferentes rutas." src="../_images/kubernetes-ingress.png" style="width: 90.0%;" /></a>
<p class="caption"><span class="caption-number">Figura 20 </span><span class="caption-text">Ejemplo de un hipotético uso de Ingress con diferentes rutas.</span><a class="headerlink" href="#fig-k8s-ingress" title="Enlace permanente a esta imagen">¶</a></p>
</div>
</div>
<div class="section" id="kafka-y-strimzi">
<span id="subsec-kafka"></span><h3>Kafka y Strimzi<a class="headerlink" href="#kafka-y-strimzi" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Uno de los principales aspectos a considerar a la hora de implementar
una arquitectura de microservicios, reside en la estrategia que se va
seguir para permitir la comunicación entre los diferentes
microservicios.</p>
<p>Dicha comunicación puede llevarse a cabo de forma síncrona, por ejemplo
a través de peticiones HTTP, o asíncrona, con tecnologías como Apache
Kafka <a class="reference internal" href="#microsoft-microsvcs" id="id10"><span>[microsoft-microsvcs]</span></a>.</p>
<p>En nuestro caso la comunicación síncrona quedó rápidamente descartada,
dado que la generación de resúmenes presenta tiempos de latencia que
pueden ser elevados (del orden de segundos o incluso minutos).
Decidimos, por tanto, adoptar la segunda opción.</p>
<p>Apache Kafka nació internamente en LinkedIn, aunque actualmente es
<em>open-source</em> y su desarrollo corre a cargo de la Apache Software
Foundation  <a class="reference internal" href="#wiki-kafka" id="id11"><span>[wiki-kafka]</span></a>.</p>
<p>Kafka permite el intercambio asíncrono de mensajes entre productores y
consumidores. En esencia, su funcionamiento es conceptualmente sencillo
y está alineado con tecnologías más tradicionales: los consumidores se
subscriben a un tema (<em>topic</em>), a los que los productores envían sus
mensajes. La consumición de dichos mensajes es asíncrona.</p>
<p>La novedad de Kafka reside, entre otras cosas, en su gran capacidad de
escalado, pudiendo soportar billones de mensajes al día; su
funcionamiento distribuido, de manera que puede operar fácilmente a lo
largo de diferentes zonas geográficas; su gran fiabilidad en entornos
críticos, en los que la pérdida de un solo mensaje es inadmisible; o su
tolerancia frente a fallos <a class="reference internal" href="#apache-kafka" id="id12"><span>[apache-kafka]</span></a>.</p>
<p>Todas estas demandas no suponen, sin embargo, que Kafka no se pueda
aplicar de igual modo a entornos más reducidos, como es el nuestro.
Además, gracias a Strimzi, otro proyecto también <em>open-source</em>, el
despliegue de Kafka en Kubernetes se simplifica en gran medida.</p>
<p>Si volvemos a observar la figura que ilustra la arquitectura general del
<em>backend</em>, podemos ver que JIZT dispone de cinco <em>topics</em>, los cuales se
corresponden con cada una de las etapas en la generación resúmenes.</p>
<div class="figure align-default" id="fig-overview-arch-2">
<img alt="Vista general de la arquitectura del *backend*." src="../_images/overview-arch1.png" />
<p class="caption"><span class="caption-number">Figura 21 </span><span class="caption-text">Vista general de la arquitectura del <em>backend</em>.</span><a class="headerlink" href="#fig-overview-arch-2" title="Enlace permanente a esta imagen">¶</a></p>
</div>
<p>Con esta figura en mente, el proceso completo que se sigue es el
siguiente:</p>
<ol class="arabic simple">
<li><p>El cliente realiza una petición HTTP POST solicitando un nuevo
resumen. Para ello, debe incluir en el cuerpo el texto a resumir, y
de manera opcional los parámetros del resumen a generar.</p></li>
<li><p>Ingress (API <em>Gateway</em>) comprueba que dicha petición se está haciendo
a un <em>endpoint</em> válido, y en ese caso la redirige hacia el
<em>Dispatcher</em>. En caso contrario devolverá un error HTTP 404.</p></li>
<li><p>El <em>Dispatcher</em> realiza una serie de comprobaciones:</p>
<ol class="arabic simple">
<li><p>Si la petición no contiene ningún texto, se devuelve un error. En
el caso de los parámetros, si son incorrectos o inexistentes, se
ignoran y se utilizan valores por defecto.</p></li>
<li><p>Se consulta en la base de datos si ya existe un resumen generado
para ese texto con esos mismos parámetros. En ese caso, lo
devuelve directamente, sin generar de nuevo el resumen.</p></li>
<li><p>En caso contrario, produce un mensaje al <em>topic</em> del
pre-procesador de textos, conteniendo el texto y los parámetros
del resumen.</p></li>
</ol>
</li>
<li><p>El pre-procesador está constantemente comprobando si existen mensajes
nuevos en su <em>topic</em>. En ese caso los consume, realiza las tareas de
pre-procesado, y produce el resultado en el <em>topic</em> del codificador.</p></li>
<li><p>Este proceso continua de forma análoga hasta llegar al
post-procesador, el cual produce el resumen final al <em>topic</em>
«Listo» (<em>Ready</em>). El <em>Dispatcher</em>, en ese momento, consume el
mensaje, actualiza la base de datos, y proporciona el resumen al
cliente.</p></li>
</ol>
<p>En dicha figura, vemos también que el <em>Dispatcher</em> consume de todos los
<em>topics</em>. Esto permite actualizar el <em>estado</em> del resumen
(pre-procesando, resumiendo, post-procesando, o listo), según va pasando
por las diferentes etapas, a fin de proporcionar una retroalimentación
más detallada al usuario.</p>
<p>Finalmente, cabe destacar una vez más la facilidad de escalado que nos
proporciona Kafka: si, por ejemplo, ampliásemos nuestra arquitectura de
modo que tuviéramos tres réplicas de cada microservicio, Kafka se
encargaría automáticamente de coordinar la producción y consumición concurrente de
mensajes de cada <em>topic</em>, sin que nosotros tuviéramos que llevar a cabo
ninguna acción adicional.</p>
</div>
<div class="section" id="helm">
<h3>Helm<a class="headerlink" href="#helm" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Helm se define frecuentemente como un gestor de paquetes para
Kubernetes, aunque en la práctica va más allá.</p>
<p>La configuración de Kubernetes se lleva a cabo, principalmente, de forma
declarativa a través de ficheros en formato <code class="docutils literal notranslate"><span class="pre">yaml</span></code>, lo que en inglés
se conoce como <em>templating</em>. Nuestro proyecto, el cual es relativamente
pequeño, hace uso de más de 20 de estos ficheros de configuración. Es
fácil imaginarse, por tanto, que un proyecto de mediana escala contendrá
cientos de <em>templates</em>.</p>
<p>Helm permite, a través de un único comando, desplegar todos estos
componentes de forma automática, gestionando aspectos como el orden en
el que se crean los componentes, el cual en muchos casos no es trivial.
Una vez instalados, a través de otro comando, podemos actualizar los
posibles cambios que haya sufrido alguno de los <em>templates</em>, de forma
que solo afecte a los componentes involucrados en dichas modificaciones,
y lleva a cabo la actualización sin tiempos de interrupción.</p>
<p>Además, a tráves de las llamadas <em>Library Charts</em> <a class="reference internal" href="#helm-lib-charts" id="id13"><span>[helm-lib-charts]</span></a>, Helm nos permite generar una plantilla que varios
componentes pueden reutilizar. Esto es muy apropiado en nuestro caso
dado que todos nuestros microservicios tienen una estructura similar; lo
único que cambia es la imagen (contenedor) que implementan.</p>
<p>Una última ventaja es que podemos distribuir el <em>backend</em> de JIZT como
un único paquete, facilitando su instalación por parte de otros
desarrolladores.</p>
</div>
<div class="section" id="crunchy-postgresql-operator">
<h3>Crunchy PostgreSQL Operator<a class="headerlink" href="#crunchy-postgresql-operator" title="Enlazar permanentemente con este título">¶</a></h3>
<p>De igual modo que Strimzi facilita el despliegue de Kafka en Kubernetes,
el operador para PostgreSQL de Crunchy automatiza y simplifica el
despliegue de <em>clústers</em> PostgreSQL en Kubernetes <a class="reference internal" href="2_Objetivos_del_proyecto.html#crunchy21" id="id14"><span>[crunchy21]</span></a>.</p>
<p>De este modo, podemos implementar una base de datos que almacene los
resúmenes generados<a class="footnote-reference brackets" href="#id25" id="id15">2</a>, con dos propósitos principales: (a) servir
como capa de caché, evitando tener que producir el mismo resumen en
repetidas ocasiones, y (b) construir un <em>dataset</em> que se podría utilizar
en un futuro para tareas de evaluación, o incluso para el entrenamiento
de otros modelos.</p>
<p>La estructura de tablas empleada para la base de datos se puede
consultar en los Anexos, en el apéndice de <a class="reference internal" href="../anexos/C_Diseno.html#apendix-diseno"><span class="std std-ref">Especificación de diseño</span></a>.</p>
<p>Este operador coordina de forma automática los accesos a la base de
datos, asegurando la integridad de la misma. Esto es posible dado que
solo existe un única instancia (<em>pod</em>) con capacidades de
escritura-lectura. El resto de instancias que accedan a la base de
datos, solo podrán leer de la misma. Si la instancia primaria fallara,
el operador se encargaría inmediatamente de elegir otra instancia como
primaria.</p>
</div>
<div class="section" id="flask-y-flask-restful">
<h3>Flask y Flask-RESTful<a class="headerlink" href="#flask-y-flask-restful" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Flask es uno de los <em>frameworks</em> más populares para la creación de aplicaciones <em>web</em>
en Python <a class="reference internal" href="#flask" id="id16"><span>[flask]</span></a>, concebido para ser lo más simple posible. En nuestro caso, hemos
empleado esta herramienta para implementar la lógica de la API REST. Además, hemos
utilizado una conocida extensión de Flask, Flask-RESTful <a class="reference internal" href="#flaskrestful" id="id17"><span>[flaskRestful]</span></a>, orientada a
la construcción de APIs REST, como es nuestro caso.</p>
<p>Dado que es el <em>Dispatcher</em> quien implementa la API REST, es únicamente
este microservicio el que hace uso de este <em>framework</em>.</p>
</div>
</div>
<div class="section" id="frontend-aplicacion-multiplataforma">
<span id="sec-frontend"></span><h2><em>Frontend</em> — Aplicación multiplataforma<a class="headerlink" href="#frontend-aplicacion-multiplataforma" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="section" id="flutter">
<h3>Flutter<a class="headerlink" href="#flutter" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Flutter es un <em>kit</em> de herramientas de UI (interfaz de usuario) que, a
partir del mismo código fuente base, permite compilar de forma nativa
aplicaciones para móvil, <em>web</em> y escritorio <a class="reference internal" href="../anexos/A_Plan_proyecto.html#flutter-es" id="id18"><span>[flutter-es]</span></a>, lo cual permite <a class="reference internal" href="#miola20" id="id19"><span>[miola20]</span></a>:</p>
<ul class="simple">
<li><p>Un desarrollo más rápido, dado que solo se trabaja en una única base
de código.</p></li>
<li><p>Costes más bajos, ya que solo mantenemos un proyecto en vez de
varios.</p></li>
<li><p>Una mayor consistencia, proporcionando al usuario la misma interfaz
gráfica y herramientas en las distintas plataformas, conservando los
patrones de interacción de cada una de ellas.</p></li>
</ul>
<p>Pese a ser desarrollado por Google desde su nacimiento en 2017, Flutter
cuenta en la actualidad con un gran apoyo de la comunidad <em>open-source</em>.
Esto ha contribuido en gran medida al desarrollo de Flutter, y en
nuestro caso nos ha facilitado la resolución de dudas y errores a la
hora de desarrollar nuestra aplicación.</p>
<p>Flutter emplea el lenguaje de programación Dart, un lenguaje orientado a
objetos que guarda ciertas similitudes con otros lenguajes como Java o
C#. Existen numerosos aspectos de Flutter y Dart que cabría explicar; no
obstante, en pos de la brevedad introduciremos uno de los que más
interesantes y relevantes nos parecen para este proyecto: ¿Cómo se
consigue que Dart pueda ser ejecutado nativamente en plataformas que
pueden resultar tan dispares como Android, iOS, <em>web</em>, Windows o
GNU/Linux?</p>
<p>Para responder a esta pregunta, es importante comenzar indicando que en
el contexto de Flutter, se opera de manera diferente en el entorno de
desarrollo y en el entorno de producción.</p>
<p>Veamos cuáles son las diferencias principales.</p>
<div class="section" id="desarrollo-nativo-plataformas-x64-arm">
<h4>Desarrollo nativo (plataformas x64/ARM)<a class="headerlink" href="#desarrollo-nativo-plataformas-x64-arm" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Así como Java requiere de la JVM (<em>Java Virtual Machine</em>) para
ejecutarse, Dart también dispone de su propia DVM (<em>Dart Virtual
Machine</em>).</p>
<p>Durante la etapa de desarrollo, la máquina DVM se utiliza en combinación
con un compilador JIT (<em>Just In Time</em>), es decir, se lleva a cabo una
compilación en tiempo de ejecución, en lugar de <em>antes</em> de la ejecución.
Esto permite tratar con el código de forma dinámica independientemente
de la arquitectura de la máquina sobre la que se trabaje.</p>
<p>Además, esta forma de operar hace posible lo que se conoce como <em>hot
reload</em>, que permite visualizar los cambios realizados en la aplicación
de manera prácticamente instantánea, dado que los cambios en el código
se transfieren a la DVM, pero se conserva el estado de la <em>app</em>
<a class="reference internal" href="#flutter-hot-reload" id="id20"><span>[flutter-hot-reload]</span></a>. Esto decrementa
notablemente los tiempos empleados en el <em>debug</em> de las aplicaciones.</p>
</div>
<div class="section" id="desarrollo-web">
<h4>Desarrollo <em>web</em><a class="headerlink" href="#desarrollo-web" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Durante el desarrollo, el compilador de desarrollo Dart, conocido como
<code class="docutils literal notranslate"><span class="pre">dartdevc</span></code>, permite ejecutar y depurar aplicaciones <em>web</em> Dart en
Google Chrome. Usado en combinación con otras herramientas como
<code class="docutils literal notranslate"><span class="pre">webdev</span></code>, el cual proporciona un servidor <em>web</em> de desarrollo, podemos
visualizar en nuestro navegador los cambios realizados en el código
fuente de manera casi inmediata.</p>
</div>
<div class="section" id="produccion-nativa-plataformas-x64-arm">
<h4>Producción nativa (plataformas x64/ARM)<a class="headerlink" href="#produccion-nativa-plataformas-x64-arm" title="Enlazar permanentemente con este título">¶</a></h4>
<p>En este caso se emplea lo que se conoce como compilación anticipada (AOT,
<em>Ahead-of-time</em> Compilation). Gracias a esta estrategia, el compilador de Dart es
capaz de traducir un lenguaje de alto nivel, como en este caso Dart, a código máquina
x64/ARM nativo <a class="reference internal" href="#aot-wiki" id="id21"><span>[aot-wiki]</span></a>. Este código máquina sí que será, a partir de
este momento, dependiente del sistema.</p>
<p>Como consecuencia de lo anterior, en este caso ya no es necesario
emplear una DVM, ya que con la compilación AOT obtenemos, para cada
plataforma, un único binario ejecutable (<code class="docutils literal notranslate"><span class="pre">.apk</span></code> o <code class="docutils literal notranslate"><span class="pre">.aab</span></code> para
Android, <code class="docutils literal notranslate"><span class="pre">.exe</span></code> para Windows, etc.).</p>
<p>La compilación AOT es, por tanto, lo que realmente convierte a Flutter
en una herramienta rápida y portable.</p>
</div>
<div class="section" id="produccion-web">
<h4>Producción <em>web</em><a class="headerlink" href="#produccion-web" title="Enlazar permanentemente con este título">¶</a></h4>
<p>El código Dart también puede ser traducido a HTML, CSS y JavaScript (en
el caso de este último gracias a una herramienta llamada <code class="docutils literal notranslate"><span class="pre">dart2js</span></code>).</p>
<p>Esto significa que podemos ejecutar nuestra aplicación en nuestro navegador<a class="footnote-reference brackets" href="#id26" id="id22">3</a>, y
la interfaz gráfica será la misma que en el resto de plataformas.</p>
<p>Es importante mencionar, que el soporte para <em>web</em> de Flutter se
encuentra aún en fase <em>beta</em>, por lo que no se recomienda para
producción <a class="reference internal" href="#flutter-web" id="id23"><span>[flutter-web]</span></a>. No obstante, nosotros no
hemos experimentado problemas con nuestra aplicación en ninguno de los
navegadores soportados.</p>
<dl class="footnote brackets">
<dt class="label" id="id24"><span class="brackets"><a class="fn-backref" href="#id3">1</a></span></dt>
<dd><p>Cabe recordar que los modelos se ejecutan en «la nube». Contratar
equipos que dispongan de GPU aumentaría notablemente los costes.</p>
</dd>
<dt class="label" id="id25"><span class="brackets"><a class="fn-backref" href="#id15">2</a></span></dt>
<dd><p>Una de las futuras historias de usuario implementará un «modo
privado», de forma que los usuarios tengan la posibilidad de generar
sus resúmenes sin que se almacenen de manera permanente.</p>
</dd>
<dt class="label" id="id26"><span class="brackets"><a class="fn-backref" href="#id22">3</a></span></dt>
<dd><p>Por ahora, solo Chrome, Safari, Edge y Firefox están soportados
<a class="reference internal" href="#flutter-web" id="id27"><span>[flutter-web]</span></a>.</p>
</dd>
</dl>
<dl class="citation">
<dt class="label" id="t5-hf"><span class="brackets"><a class="fn-backref" href="#id1">t5-hf</a></span></dt>
<dd><p>Hugging Face. Model t5-large. Feb. de 2021. URL:
<a class="reference external" href="https://huggingface.co/t5-large">https://huggingface.co/t5-large</a>.
Último acceso: 03/02/2021.</p>
</dd>
<dt class="label" id="hf-pretrained"><span class="brackets"><a class="fn-backref" href="#id2">hf-pretrained</a></span></dt>
<dd><p>Hugging Face. Pretrained models. Feb. de 2021. URL:
<a class="reference external" href="https://huggingface.co/transformers/pretrained_models.html">https://huggingface.co/transformers/pretrained_models.html</a>.
Último acceso: 03/02/2021.</p>
</dd>
<dt class="label" id="id28"><span class="brackets">kubernetes</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id7">2</a>)</span></dt>
<dd><p>Kubernetes. What is Kubernetes? Oct. de 2020. URL:
<a class="reference external" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes</a>.
Último acceso: 03/02/2021.</p>
</dd>
<dt class="label" id="newman15"><span class="brackets"><a class="fn-backref" href="#id5">newman15</a></span></dt>
<dd><p>Sam Newman. Building Microservices. O’Reilly Media, Inc., feb. de
2015. ISBN: 9781491950357.</p>
</dd>
<dt class="label" id="id29"><span class="brackets"><a class="fn-backref" href="#id6">docker</a></span></dt>
<dd><p>Docker. Why Docker? 2021. URL:
<a class="reference external" href="https://www.docker.com/why-docker">https://www.docker.com/why-docker</a>.
Último acceso: 03/02/2021.</p>
</dd>
<dt class="label" id="k8s-scheduling"><span class="brackets"><a class="fn-backref" href="#id8">k8s-scheduling</a></span></dt>
<dd><p>Kubernetes. Scheduling and Eviction. Jun. de 2020. URL:
<a class="reference external" href="https://kubernetes.io/docs/concepts/scheduling-eviction">https://kubernetes.io/docs/concepts/scheduling-eviction</a>.
Último acceso: 04/02/2021.</p>
</dd>
<dt class="label" id="api-gateway"><span class="brackets"><a class="fn-backref" href="#id9">api-gateway</a></span></dt>
<dd><p>Nginx. What is an API Gateway? Sep. de 2020. URL:
<a class="reference external" href="https://www.nginx.com/learn/api-gateway">https://www.nginx.com/learn/api-gateway</a>.
Último acceso: 04/02/2021.</p>
</dd>
<dt class="label" id="microsoft-microsvcs"><span class="brackets"><a class="fn-backref" href="#id10">microsoft-microsvcs</a></span></dt>
<dd><p>Microsoft Docs. Communication in a microservice architecture. Ene. de
2020. URL:
<a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/communication-in-microservice-architecture">https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/communication-in-microservice-architecture</a>.
Último acceso: 04/02/2021.</p>
</dd>
<dt class="label" id="wiki-kafka"><span class="brackets"><a class="fn-backref" href="#id11">wiki-kafka</a></span></dt>
<dd><p>Wikipedia. Apache Kafka. Ene. de 2021. URL:
<a class="reference external" href="https://en.wikipedia.org/wiki/Apache_Kafka">https://en.wikipedia.org/wiki/Apache_Kafka</a>.
Último acceso: 04/02/2021.</p>
</dd>
<dt class="label" id="apache-kafka"><span class="brackets"><a class="fn-backref" href="#id12">apache-kafka</a></span></dt>
<dd><p>Apache Software Foundation. Apache Kafka. Nov. de 2020. URL:
<a class="reference external" href="https://kafka.apache.org">https://kafka.apache.org</a>.
Último acceso: 04/02/2021.</p>
</dd>
<dt class="label" id="helm-lib-charts"><span class="brackets"><a class="fn-backref" href="#id13">helm-lib-charts</a></span></dt>
<dd><p>Helm - The package manager for Kubernetes. Library Charts. Ene. de
2021. URL:
<a class="reference external" href="https://helm.sh/docs/topics/library_charts">https://helm.sh/docs/topics/library_charts</a>.
Último acceso: 04/02/2021.</p>
</dd>
<dt class="label" id="flask"><span class="brackets"><a class="fn-backref" href="#id16">flask</a></span></dt>
<dd><p>The Pallets Projects. Flask. 2021. URL:
<a class="reference external" href="https://palletsprojects.com/p/flask">https://palletsprojects.com/p/flask</a>.
Último acceso: 04/02/2021.</p>
</dd>
<dt class="label" id="flaskrestful"><span class="brackets"><a class="fn-backref" href="#id17">flaskRestful</a></span></dt>
<dd><p>Flask-RESTful Community. Flask-RESTful. 2021. URL:
<a class="reference external" href="https://flask-restful.readthedocs.io/en/latest">https://flask-restful.readthedocs.io/en/latest</a>.
Último acceso: 04/02/2021.</p>
</dd>
<dt class="label" id="miola20"><span class="brackets"><a class="fn-backref" href="#id19">miola20</a></span></dt>
<dd><p>Alberto Miola. Flutter Complete Reference: Create beautiful, fast and
native apps for any device. Sep. de 2020. ISBN: 9798691939952.</p>
</dd>
<dt class="label" id="flutter-hot-reload"><span class="brackets"><a class="fn-backref" href="#id20">flutter-hot-reload</a></span></dt>
<dd><p>Flutter. Hot reload. Mayo de 2020. URL:
<a class="reference external" href="https://flutter.dev/docs/development/tools/hot-reload">https://flutter.dev/docs/development/tools/hot-reload</a>.
Último acceso: 09/02/2021.</p>
</dd>
<dt class="label" id="aot-wiki"><span class="brackets"><a class="fn-backref" href="#id21">aot-wiki</a></span></dt>
<dd><p>Wikipedia. Compilación anticipada. Dic. de 2020. URL:
<a class="reference external" href="https://es.wikipedia.org/wiki/Compilación_anticipada">https://es.wikipedia.org/wiki/Compilación_anticipada</a>.
Último acceso: 05/02/2021.</p>
</dd>
<dt class="label" id="flutter-web"><span class="brackets">flutter-web</span><span class="fn-backref">(<a href="#id23">1</a>,<a href="#id27">2</a>)</span></dt>
<dd><p>Flutter. Web FAQ. Oct. de 2020. URL:
<a class="reference external" href="https://flutter.dev/docs/development/platform-integration/web">https://flutter.dev/docs/development/platform-integration/web</a>.
Último acceso: 05/02/2021.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="5_Aspectos_relevantes_del_desarrollo_del_proyecto.html" class="btn btn-neutral float-right" title="Aspectos relevantes del desarrollo del proyecto" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="3_Conceptos_teoricos.html" class="btn btn-neutral float-left" title="Conceptos teóricos" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Derechos de autor 2021, Diego Miguel Lozano.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>